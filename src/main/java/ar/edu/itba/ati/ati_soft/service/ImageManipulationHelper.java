package ar.edu.itba.ati.ati_soft.service;

import ar.edu.itba.ati.ati_soft.models.Histogram;
import ar.edu.itba.ati.ati_soft.models.Image;
import ar.edu.itba.ati.ati_soft.utils.QuadFunction;
import ar.edu.itba.ati.ati_soft.utils.TriFunction;
import org.springframework.util.Assert;

import java.util.Arrays;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Helper class that implements methods that help services.
 */
/* package */ class ImageManipulationHelper {


    /**
     * Normalizes the given {@link Image} to have pixel values between 0.0 and 255.0.
     *
     * @param original The original {@link Image}.
     * @return The normalized {@link Image}.
     */
    /* package */
    static Image normalize(Image original) {
        final MinAndMaxContainer container = new MinAndMaxContainer(original).initialize();
        final Double[] minimums = container.getMinimums();
        final Double[] maximums = container.getMaximums();
        final double[] factors = IntStream.range(0, original.getBands())
                .mapToDouble(i -> 255 / (maximums[i] - minimums[i])).toArray();
        return createApplying(original, (x, y, i, value) -> (value - minimums[i]) * factors[i]);
    }


    /**
     * Applies a threshold to the given {@link Image}, using the given threshold {@code value}.
     *
     * @param image The {@link Image} to which the threshold will be applied.
     * @param value The threshold value.
     * @return The threshold {@link Image}.
     * @apiNote This method expects the {@link Image} to be gray and normalized.
     */
    /* package */
    static Image threshold(Image image, int value) {
        return createApplying(image, (x, y, b, v) -> (double) (v <= value ? 0x0 : 0xFF));
    }

    /**
     * Converts the given {@link Image} into a gray image.
     *
     * @param image The {@link Image} to be converted.
     * @return A new instance of {@link Image}, which is the converted {@link Image} of the given one.
     * @implNote This method uses the euclidean distance of each pixel
     * (being the space the one formed by all the image's bands).
     */
    /* package */
    static Image toGray(Image image) {
        if (image.getBands() == 1) {
            return image.copy(); // Called of the method expects a new instance
        }
        return createApplying(image, (x, y, b, v) -> getEuclideanDistance(image.getPixel(x, y)));
    }

    /**
     * Creates a new {@link Image}, generating the canvas with the given {@code canvasSupplier},
     * setting pixels using the given {@code pixelSetter} {@link BiFunction} to each pixel.
     *
     * @param canvasSupplier A {@link Supplier} of {@link Image}, which will be used to generate the canvas
     *                       (i.e the {@link Image} to be returned,
     *                       which in turn will be modified by the given {@link BiFunction}).
     * @param pixelSetter    The {@link BiFunction} to apply to each pixel,
     *                       being the first element, the row of the pixel being set,
     *                       and the second element, the column of the pixel being set.
     *                       The function must return the pixel to be set
     *                       (which must match the amount of bands the {@link Image}
     *                       generated by the {@code canvasSupplier} has).
     * @return The new {@link Image}.
     */
    /* package */
    static Image createApplying(Supplier<Image> canvasSupplier, BiFunction<Integer, Integer, Double[]> pixelSetter) {
        final Image canvas = canvasSupplier.get();
        populate(canvas, pixelSetter);
        return canvas;
    }

    /**
     * Creates a new {@link Image} using as base the given {@code original} {@link Image},
     * applying the given {@code changer} {@link QuadFunction} to each sample.
     *
     * @param original The base {@link Image}.
     * @param changer  The {@link QuadFunction} to apply to each pixel,
     *                 being the first element, the row of the pixel being changed,
     *                 the second element, the column of the pixel being changed,
     *                 the third element, the band being changed,
     *                 and the fourth element, the original value in the row, column and band.
     *                 The function must return the changed value.
     * @return The new {@link Image}.
     */
    /* package */
    static Image createApplying(Image original, QuadFunction<Integer, Integer, Integer, Double, Double> changer) {
        return createApplying(original.getWidth(), original.getHeight(), original.getBands(),
                (x, y, b) -> changer.apply(x, y, b, original.getSample(x, y, b)));
    }

    /**
     * Creates a new {@link Image} with the given {@code width}, {@code height}, and {@code bands},
     * setting pixels using the given {@code pixelSetter} {@link TriFunction} to each sample.
     *
     * @param width       The {@link Image} width.
     * @param height      The {@link Image} height.
     * @param bands       The {@link Image} bands.
     * @param pixelSetter The {@link TriFunction} to apply to each pixel,
     *                    being the first element, the row of the pixel being set,
     *                    the second element, the column of the pixel being set,
     *                    the third element, the band being set,
     *                    The function must return the value to be set.
     * @return The new {@link Image}.
     */
    /* package */
    static Image createApplying(int width, int height, int bands,
                                TriFunction<Integer, Integer, Integer, Double> pixelSetter) {
        return createApplying(() -> Image.trash(width, height, bands), pixelSetter);
    }


    /**
     * Creates a new {@link Image}, generating the canvas with the given {@code canvasSupplier},
     * setting pixels using the given {@code pixelSetter} {@link TriFunction} to each sample.
     *
     * @param canvasSupplier A {@link Supplier} of {@link Image}, which will be used to generate the canvas
     *                       (i.e the {@link Image} to be returned,
     *                       which in turn will be modified by the given {@link TriFunction}).
     * @param pixelSetter    The {@link TriFunction} to apply to each pixel,
     *                       being the first element, the row of the pixel being set,
     *                       the second element, the column of the pixel being set,
     *                       the third element, the band being set,
     *                       The function must return the value to be set.
     * @return The new {@link Image}.
     */
    /* package */
    static Image createApplying(Supplier<Image> canvasSupplier,
                                TriFunction<Integer, Integer, Integer, Double> pixelSetter) {
        final Image canvas = canvasSupplier.get();
        populate(canvas, pixelSetter);
        return canvas;
    }


    /**
     * Populates the given {@code canvas} {@link Image}, according to the given {@link TriFunction}
     * (which generates the values for the canvas)
     *
     * @param canvas      An {@link Image} which will be populated with the {@link TriFunction}.
     * @param pixelSetter The {@link TriFunction} to apply to each pixel,
     *                    being the first element, the row of the pixel being set,
     *                    the second element, the column of the pixel being set,
     *                    the third element, the band being set,
     *                    The function must return the value to be set.
     */
    /* package */
    static void populate(Image canvas, TriFunction<Integer, Integer, Integer, Double> pixelSetter) {
        for (int x = 0; x < canvas.getWidth(); x++) {
            for (int y = 0; y < canvas.getHeight(); y++) {
                for (int b = 0; b < canvas.getBands(); b++) {
                    canvas.setSample(x, y, b, pixelSetter.apply(x, y, b));
                }
            }
        }
    }

    /**
     * Populates the given {@code canvas} {@link Image} using the given {@code pixelSetter}.
     *
     * @param canvas      The {@link Image} that will be modified.
     * @param pixelSetter A {@link BiFunction} that given a position in an {@link Image}, sets the pixel for it.
     * @throws IllegalArgumentException In case the {@code pixelSetter} returns a pixel
     *                                  that does not match the dimension of the {@code canvas}.
     * @apiNote The {@code pixelSetter} must return a pixel with the amount of bands the given {@code canvas}
     * {@link Image} support.
     * @implNote This method avoids looping for each element in a pixel
     * by setting the entire pixel in the {@code canvas} {@link Image}.
     */
    /* package */
    static void populate(Image canvas, BiFunction<Integer, Integer, Double[]> pixelSetter)
            throws IllegalArgumentException {
        for (int x = 0; x < canvas.getWidth(); x++) {
            for (int y = 0; y < canvas.getHeight(); y++) {
                for (int b = 0; b < canvas.getBands(); b++) {
                    canvas.setPixel(x, y, pixelSetter.apply(x, y));
                }
            }
        }
    }

    /**
     * Calculates the {@link Histogram} of the given {@link Image}, for the given {@code band}.
     *
     * @param image The {@link Image} whose {@link Histogram} will be calculated.
     * @param band  The band to be calculated.
     * @return The calculated {@link Histogram}.
     */
    /* package */
    static Histogram getHistogram(Image image, int band) {
        final Map<Integer, Long> values = IntStream.range(0, image.getWidth())
                .parallel()
                .mapToObj(x -> IntStream.range(0, image.getHeight())
                        .parallel()
                        .mapToObj(y -> image.getSample(x, y, band)))
                .flatMap(Function.identity())
                .map(Double::intValue)
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        return new Histogram(values);
    }

    /**
     * Calculates the euclidean distance of the given {@code pixel}.
     *
     * @param pixel The pixel whose euclidean distance will be calculated.
     * @return The euclidean distance of the given {@code pixel}.
     */
    private static double getEuclideanDistance(Double[] pixel) {
        return Math.sqrt(Arrays.stream(pixel)
                .mapToDouble(i -> i)
                .map(p -> p * p)
                .sum());
    }

    /**
     * Container class holding minimums and maximums values for a given {@link Image}.
     */
    /* package */ final static class MinAndMaxContainer {

        /**
         * An array holding the min. values.
         */
        private final Double[] minimums;

        /**
         * An array holding the max. values.
         */
        private final Double[] maximums;

        /**
         * The {@link Image} to which min. and max. values will be calculated, stored for lazy initialization.
         */
        private final Image image;

        /**
         * Constructor.
         *
         * @param image The {@link Image} to which min. and max. values will be calculated.
         */
        /* package */ MinAndMaxContainer(Image image) {
            this.minimums = image.getPixel(0, 0);
            this.maximums = image.getPixel(0, 0);
            this.image = image;
        }

        /**
         * Initializes this container.
         *
         * @return {@code this}, for method chaining.
         */
        /* package */ MinAndMaxContainer initialize() {
            populate(image, minimums, maximums);
            return this;
        }

        /**
         * @return The array containing the min. values.
         */
        /* package */ Double[] getMinimums() {
            return Arrays.copyOf(minimums, minimums.length);
        }

        /**
         * @return The array containing the max. values.
         */
        /* package */ Double[] getMaximums() {
            return Arrays.copyOf(maximums, maximums.length);
        }

        /**
         * Populates the given {@code minimums} and {@code maximums} arrays
         * with the minimums and maximums values for each band.
         *
         * @param image    The {@link Image} to which the calculation will be performed.
         * @param minimums An array to which the minimum value for each band will be saved.
         * @param maximums An array to which the maximum value for each band will be saved.
         * @throws IllegalArgumentException If any of the arrays are null, or if both arrays don'thave the same length.
         */
        private void populate(Image image, final Double[] minimums, final Double[] maximums)
                throws IllegalArgumentException {
            Assert.notNull(minimums, "The minimums array must not be null");
            Assert.notNull(maximums, "The maximums array must not be null");
            if (minimums.length != maximums.length) {
                throw new IllegalArgumentException("Both minimums and maximums array must have the same length");
            }
            for (int x = 0; x < image.getWidth(); x++) {
                for (int y = 0; y < image.getHeight(); y++) {
                    for (int i = 0; i < image.getBands(); i++) {
                        final double value = image.getSample(x, y, i);
                        maximums[i] = maximums[i] > value ? maximums[i] : value;
                        minimums[i] = minimums[i] < value ? minimums[i] : value;
                    }
                }
            }
        }
    }

    /**
     * Bean class representing a position in an {@link Image}.
     */
    /* package */ static final class ImagePosition {

        /**
         * The position in 'x'.
         */
        private final int x;
        /**
         * The position in 'y'.
         */
        private final int y;

        /**
         * Constructor.
         *
         * @param x The position in 'x'.
         * @param y The position in 'y'.
         */
        /* package */ ImagePosition(int x, int y) {
            this.x = x;
            this.y = y;
        }

        /**
         * @return The position in 'x'.
         */
        public int getX() {
            return x;
        }

        /**
         * @return The position in 'x'.
         */
        public int getY() {
            return y;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof ImagePosition)) {
                return false;
            }
            final ImagePosition that = (ImagePosition) o;
            return x == that.x && y == that.y;
        }

        @Override
        public int hashCode() {
            int result = x;
            result = 31 * result + y;
            return result;
        }
    }
}
